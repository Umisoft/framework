<?php
/**
 * UMI.Framework (http://umi-framework.ru/)
 * @link      http://github.com/Umisoft/framework for the canonical source repository
 * @copyright Copyright (c) 2007-2013 Umisoft ltd. (http://umisoft.ru/)
 * @license   http://umi-framework.ru/license/bsd-3 BSD-3 License
 */

namespace umi\dbal\cluster;

use umi\dbal\cluster\server\IMasterServer;
use umi\dbal\cluster\server\IServer;
use umi\dbal\cluster\server\ISlaveServer;
use umi\dbal\exception\NonexistentEntityException;

/**
 * Компонент для работы с БД.
 * Компонент для работы с БД, поддерживает репликацию и вертикальный шардинг данных
 *    <ul>
 *        <li>предоставляет всем компонентам единый интерфейс для выполнения запросов</li>
 *        <li>позволяет организовать master-slave's, master-master репликацию</li>
 *        <li>позволяет подключить свой класс-балансировщик нагрузки</li>
 *        <li>позволяет организовать вертикальный шардинг данных</li>
 *        <li>поддерживает "ленивый" коннект к серверу, "ленивое" выполнение запросов</li>
 *    </ul>
 * <h3>Терминология</h3>
 * <dl>
 *    <dt>Репликация</dt>
 *    <dd>копирование данных на разные сервера, поддержка копий в актуальном состоянии,
 * распределение нагрузки между БД-серверами</dd>
 *    <dt>MasterServer-сервер</dt>
 *    <dd>это сервер БД который может обрабатывать запросы как на выборку
 * данных, так и на модификацию данных. Мастер-серверов может быть несколько, это
 * называется master-master репликация.</dd>
 *    <dt>Slave-сервер</dt>
 *    <dd>это "подчиненный" сервер, может выполнять только запросы на выборку
 * данных. Периодически получает обновления данных с master-сервера через бинарные логи.</dd>
 *    <dt>Балансировщик</dt>
 *    <dd>это механизм распределения нагрузки между серверами. По-умолчанию
 * компонент использует балансировщик (DbBalancer), работающий по принципу
 * "Round Robin".
 * Приложение может установить компоненту свою реализацию балансировщика в момент инициализации.
 *    </dd>
 *    <dt>Вертикальный шардинг</dt>
 *    <dd>распределение данных по разным серверам. Например,
 *    все данные о пользователях и заказах могут быть размещены на отдельном сервере</dd>
 *    <dt>Горизонтальный шардинг (пока не поддерживается)</dt>
 *    <dd>распределение связанных бизнес-логикой данных по серверам. Например, конкретный пользователь и все
 *    связанные с ним данные (сообщения, заказы) могут храниться на отдельном сервере
 *    </dd>
 * </dl>
 * <h3>Логика и режимы работы</h3>
 * <ul>
 *    <li>Указан единственный master-сервер (нет репликации): <br />
 * Все запросы на выборку и модификацию данных отправляются на один сервер</li>
 *    <li>Указано два или более master-сервера (master-master репликация, нет slave)
 *        <ul>
 *            <li>при попытке выполнить первый запрос/коннект определяет какой из серверов использовать
 * для выполнения этого и всех остальных запросов к бд, используя балансировщик </li>
 *            <li>все запросы на выборку и модификацию данных происходят на указанный балансировщиком сервер</li>
 *        </ul>
 *    </li>
 *    <li>Указан master-сервер и несколько slave-серверов (master-slave репликация)
 *        <ul>
 *            <li>балансировщик определяет какой сервер использовать для выборки данных и какой для модификации</li>
 *            <li>запросы на выборку и модификацию отправляются на разные сервера</li>
 *        </ul>
 *    </li>
 * </ul>
 * <p>Необходимо учитывать тот момент, что при использовании репликации slave-сервера
 * могут "отставать" от master'a по актуальности данных на какое-то время (зависит от канала, нагрузки,
 * настроек репликации).
 * Для некоторых данных (статистика, отправка формы обратной связи) это отставание не очень важно,
 * но для таких данных, как пост блога, заказ в магазине это отставание не допустимо.
 * Для решения проблемы используется следующее решение:</p>
 * <ul>
 *    <li>Действие на модификацию важных данных сообщает компоненту DbCluster, что необходимо использовать
 *    только мастер-сервер для текущей операции.</li>
 *    <li>Кластер (DbCluster) уведомляет балансировщик о том, что пользователь должен работать только
 *    с текущим мастер-сервером.</li>
 *    <li>Балансировщик своими средствами "привязывает" пользователя к master-серверу.
 *    Так же балансировщик сохраняет время привязки к мастеру. Таким образом, все пользователи,
 * которые совершили действие
 *  с важными данными привязываются к мастер-серверу на текущий и все последующие запросы.</li>
 *    <li>Для того, чтобы разгрузить мастер-сервер от таких пользователей вводится параметр
 * "время рассинхронизации кластера".
 *    </li>
 *    <li>Как только время последнего действия у привязанного к мастеру пользователя преодолевает этот параметр,
 * балансировщик "отвязывает" пользователя от мастер-сервера, т.к. на репликах данные уже обновились, пользователь
 * видит актуальную информацию. Этот параметр может быть подобран статически, либо высчитываться балансировщиком
 * динамически, в зависимости от нагрузки на кластер.</li>
 * </ul>
 * <p>Кластер может настравится динамически, например когда elastic видит что нагрузка на машины высока,
 * и поднимает парочку дополнительных слейвов mysql (дополнительные виртуальные машины в облаке), он может изменить
 * конфигурацию компонента, добавив в нее новый сервер. Таким образом, все новые коннекты будут работать с
 * новыми настройками. Тот же механизм справедлив и при удалении слейвов.</p>
 */
interface IDbCluster extends IConnection
{
    /**
     * Добавляет сервер в кластер
     * @param IServer $server сервер
     * @return self
     */
    public function addServer(IServer $server);

    /**
     * Устанавливает сервер в качестве текущего мастера
     * @param IMasterServer $server
     * @return self
     */
    public function setCurrentMaster(IMasterServer $server);

    /**
     * Установливает сервер в качестве текущего слейва
     * @param ISlaveServer $server
     * @return self
     */
    public function setCurrentSlave(ISlaveServer $server);

    /**
     * Возвращает сервер по его идентификатору
     * @param string $serverId идентификатор сервера
     * @throws NonexistentEntityException если сервер не найден
     * @return IServer
     */
    public function getServer($serverId);

    /**
     * Возвращает сервер для выборки данных
     * @return ISlaveServer
     */
    public function getSlave();

    /**
     * Возвращает сервер для модификации данных
     * @return IMasterServer
     */
    public function getMaster();
}
